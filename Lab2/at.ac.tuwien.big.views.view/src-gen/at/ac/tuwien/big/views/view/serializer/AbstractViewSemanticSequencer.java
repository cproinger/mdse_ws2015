/*
 * generated by Xtext
 */
package at.ac.tuwien.big.views.view.serializer;

import at.ac.tuwien.big.views.ClassIndexView;
import at.ac.tuwien.big.views.Column;
import at.ac.tuwien.big.views.ComparisonCondition;
import at.ac.tuwien.big.views.CompositeCondition;
import at.ac.tuwien.big.views.CreateView;
import at.ac.tuwien.big.views.DateTimePicker;
import at.ac.tuwien.big.views.DeleteView;
import at.ac.tuwien.big.views.ElementGroup;
import at.ac.tuwien.big.views.EnumerationLiteralItem;
import at.ac.tuwien.big.views.Layout;
import at.ac.tuwien.big.views.Link;
import at.ac.tuwien.big.views.List;
import at.ac.tuwien.big.views.ReadView;
import at.ac.tuwien.big.views.Selection;
import at.ac.tuwien.big.views.SelectionItem;
import at.ac.tuwien.big.views.Table;
import at.ac.tuwien.big.views.Text;
import at.ac.tuwien.big.views.UpdateView;
import at.ac.tuwien.big.views.ViewGroup;
import at.ac.tuwien.big.views.ViewModel;
import at.ac.tuwien.big.views.ViewsPackage;
import at.ac.tuwien.big.views.view.services.ViewGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractViewSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ViewGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ViewsPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ViewsPackage.CLASS_INDEX_VIEW:
				sequence_ClassIndexView(context, (ClassIndexView) semanticObject); 
				return; 
			case ViewsPackage.COLUMN:
				if(context == grammarAccess.getColumnRule() ||
				   context == grammarAccess.getPropertyElementRule()) {
					sequence_Column(context, (Column) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConditionalElementRule() ||
				   context == grammarAccess.getViewElementRule()) {
					sequence_Column_ViewElement(context, (Column) semanticObject); 
					return; 
				}
				else break;
			case ViewsPackage.COMPARISON_CONDITION:
				sequence_ComparisonCondition(context, (ComparisonCondition) semanticObject); 
				return; 
			case ViewsPackage.COMPOSITE_CONDITION:
				sequence_CompositeCondition(context, (CompositeCondition) semanticObject); 
				return; 
			case ViewsPackage.CREATE_VIEW:
				sequence_CreateView(context, (CreateView) semanticObject); 
				return; 
			case ViewsPackage.DATE_TIME_PICKER:
				if(context == grammarAccess.getDateTimePickerRule() ||
				   context == grammarAccess.getPropertyElementRule()) {
					sequence_DateTimePicker(context, (DateTimePicker) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConditionalElementRule() ||
				   context == grammarAccess.getViewElementRule()) {
					sequence_DateTimePicker_ViewElement(context, (DateTimePicker) semanticObject); 
					return; 
				}
				else break;
			case ViewsPackage.DELETE_VIEW:
				sequence_DeleteView(context, (DeleteView) semanticObject); 
				return; 
			case ViewsPackage.ELEMENT_GROUP:
				sequence_ElementGroup(context, (ElementGroup) semanticObject); 
				return; 
			case ViewsPackage.ENUMERATION_LITERAL_ITEM:
				sequence_EnumerationLiteralItem(context, (EnumerationLiteralItem) semanticObject); 
				return; 
			case ViewsPackage.LAYOUT:
				sequence_Layout(context, (Layout) semanticObject); 
				return; 
			case ViewsPackage.LINK:
				sequence_Link(context, (Link) semanticObject); 
				return; 
			case ViewsPackage.LIST:
				if(context == grammarAccess.getLinkableElementRule()) {
					sequence_LinkableElement_List(context, (List) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAssociationElementRule() ||
				   context == grammarAccess.getListRule()) {
					sequence_List(context, (List) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConditionalElementRule() ||
				   context == grammarAccess.getViewElementRule()) {
					sequence_List_ViewElement(context, (List) semanticObject); 
					return; 
				}
				else break;
			case ViewsPackage.READ_VIEW:
				sequence_ReadView(context, (ReadView) semanticObject); 
				return; 
			case ViewsPackage.SELECTION:
				if(context == grammarAccess.getPropertyElementRule() ||
				   context == grammarAccess.getSelectionRule()) {
					sequence_Selection(context, (Selection) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConditionalElementRule() ||
				   context == grammarAccess.getViewElementRule()) {
					sequence_Selection_ViewElement(context, (Selection) semanticObject); 
					return; 
				}
				else break;
			case ViewsPackage.SELECTION_ITEM:
				sequence_SelectionItem(context, (SelectionItem) semanticObject); 
				return; 
			case ViewsPackage.TABLE:
				if(context == grammarAccess.getLinkableElementRule()) {
					sequence_LinkableElement_Table(context, (Table) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAssociationElementRule() ||
				   context == grammarAccess.getTableRule()) {
					sequence_Table(context, (Table) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConditionalElementRule() ||
				   context == grammarAccess.getViewElementRule()) {
					sequence_Table_ViewElement(context, (Table) semanticObject); 
					return; 
				}
				else break;
			case ViewsPackage.TEXT:
				if(context == grammarAccess.getPropertyElementRule() ||
				   context == grammarAccess.getTextRule()) {
					sequence_Text(context, (Text) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConditionalElementRule() ||
				   context == grammarAccess.getViewElementRule()) {
					sequence_Text_ViewElement(context, (Text) semanticObject); 
					return; 
				}
				else break;
			case ViewsPackage.UPDATE_VIEW:
				sequence_UpdateView(context, (UpdateView) semanticObject); 
				return; 
			case ViewsPackage.VIEW_GROUP:
				sequence_ViewGroup(context, (ViewGroup) semanticObject); 
				return; 
			case ViewsPackage.VIEW_MODEL:
				sequence_ViewModel(context, (ViewModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         startView?='start'? 
	 *         name=ID 
	 *         header=STRING 
	 *         class=[Class|QualifiedName] 
	 *         description=STRING? 
	 *         (link+=Link link+=Link*)?
	 *     )
	 */
	protected void sequence_ClassIndexView(EObject context, ClassIndexView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING property=[Property|QualifiedName])
	 */
	protected void sequence_Column(EObject context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING property=[Property|QualifiedName] condition=Condition?)
	 */
	protected void sequence_Column_ViewElement(EObject context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (conditionID=ID property=[PropertyElement|ID] comparisonType=ComparisonConditionType comparisonValue=STRING type=VisibilityConditionType)
	 */
	protected void sequence_ComparisonCondition(EObject context, ComparisonCondition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.VISIBILITY_CONDITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.VISIBILITY_CONDITION__TYPE));
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.VISIBILITY_CONDITION__CONDITION_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.VISIBILITY_CONDITION__CONDITION_ID));
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.COMPARISON_CONDITION__COMPARISON_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.COMPARISON_CONDITION__COMPARISON_VALUE));
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.COMPARISON_CONDITION__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.COMPARISON_CONDITION__PROPERTY));
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.COMPARISON_CONDITION__COMPARISON_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.COMPARISON_CONDITION__COMPARISON_TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getComparisonConditionAccess().getConditionIDIDTerminalRuleCall_1_0(), semanticObject.getConditionID());
		feeder.accept(grammarAccess.getComparisonConditionAccess().getPropertyPropertyElementIDTerminalRuleCall_3_0_1(), semanticObject.getProperty());
		feeder.accept(grammarAccess.getComparisonConditionAccess().getComparisonTypeComparisonConditionTypeEnumRuleCall_4_0(), semanticObject.getComparisonType());
		feeder.accept(grammarAccess.getComparisonConditionAccess().getComparisonValueSTRINGTerminalRuleCall_5_0(), semanticObject.getComparisonValue());
		feeder.accept(grammarAccess.getComparisonConditionAccess().getTypeVisibilityConditionTypeEnumRuleCall_7_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         conditionID=ID 
	 *         composedConditions+=VisibilityCondition 
	 *         compositionType=CompositeConditionType 
	 *         composedConditions+=VisibilityCondition 
	 *         type=VisibilityConditionType
	 *     )
	 */
	protected void sequence_CompositeCondition(EObject context, CompositeCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         layout=Layout 
	 *         startView?='start'? 
	 *         name=ID 
	 *         header=STRING 
	 *         class=[Class|QualifiedName] 
	 *         description=STRING? 
	 *         (elementGroups+=ElementGroup elementGroups+=ElementGroup*)?
	 *     )
	 */
	protected void sequence_CreateView(EObject context, CreateView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING format=STRING? property=[Property|QualifiedName])
	 */
	protected void sequence_DateTimePicker(EObject context, DateTimePicker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING format=STRING? property=[Property|QualifiedName] condition=Condition?)
	 */
	protected void sequence_DateTimePicker_ViewElement(EObject context, DateTimePicker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         layout=Layout 
	 *         startView?='start'? 
	 *         name=ID 
	 *         header=STRING 
	 *         class=[Class|QualifiedName] 
	 *         description=STRING? 
	 *         (elementGroups+=ElementGroup elementGroups+=ElementGroup*)?
	 *     )
	 */
	protected void sequence_DeleteView(EObject context, DeleteView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (layout=Layout header=STRING (viewElements+=ViewElement viewElements+=ViewElement*)? condition=Condition?)
	 */
	protected void sequence_ElementGroup(EObject context, ElementGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING enumerationLiteral=[EnumerationLiteral|QualifiedName])
	 */
	protected void sequence_EnumerationLiteralItem(EObject context, EnumerationLiteralItem semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.SELECTION_ITEM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.SELECTION_ITEM__VALUE));
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.ENUMERATION_LITERAL_ITEM__ENUMERATION_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.ENUMERATION_LITERAL_ITEM__ENUMERATION_LITERAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEnumerationLiteralItemAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEnumerationLiteralItemAccess().getEnumerationLiteralEnumerationLiteralQualifiedNameParserRuleCall_3_0_1(), semanticObject.getEnumerationLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     alignment=LayoutStyle
	 */
	protected void sequence_Layout(EObject context, Layout semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.LAYOUT__ALIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.LAYOUT__ALIGNMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLayoutAccess().getAlignmentLayoutStyleEnumRuleCall_0(), semanticObject.getAlignment());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (label=STRING targetView=[ClassOperationView|QualifiedName])
	 */
	protected void sequence_Link(EObject context, Link semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.LINK__TARGET_VIEW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.LINK__TARGET_VIEW));
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.LINK__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.LINK__LABEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLinkAccess().getLabelSTRINGTerminalRuleCall_1_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getLinkAccess().getTargetViewClassOperationViewQualifiedNameParserRuleCall_3_0_1(), semanticObject.getTargetView());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING association=[Association|QualifiedName] (link+=Link link+=Link*)? link+=Link)
	 */
	protected void sequence_LinkableElement_List(EObject context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         elementID=ID 
	 *         label=STRING 
	 *         association=[Association|QualifiedName] 
	 *         ((link+=Link link+=Link*) | (link+=Link+ columns+=Column columns+=Column*) | (columns+=Column columns+=Column*)?) 
	 *         link+=Link
	 *     )
	 */
	protected void sequence_LinkableElement_Table(EObject context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING association=[Association|QualifiedName] (link+=Link link+=Link*)?)
	 */
	protected void sequence_List(EObject context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING association=[Association|QualifiedName] (link+=Link link+=Link*)? condition=Condition?)
	 */
	protected void sequence_List_ViewElement(EObject context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         layout=Layout 
	 *         startView?='start'? 
	 *         name=ID 
	 *         header=STRING 
	 *         class=[Class|QualifiedName] 
	 *         description=STRING? 
	 *         (elementGroups+=ElementGroup elementGroups+=ElementGroup*)?
	 *     )
	 */
	protected void sequence_ReadView(EObject context, ReadView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_SelectionItem(EObject context, SelectionItem semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ViewsPackage.Literals.SELECTION_ITEM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ViewsPackage.Literals.SELECTION_ITEM__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSelectionItemAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING property=[Property|QualifiedName] (selectionItems+=SelectionItem selectionItems+=SelectionItem*)?)
	 */
	protected void sequence_Selection(EObject context, Selection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elementID=ID label=STRING property=[Property|QualifiedName] (selectionItems+=SelectionItem selectionItems+=SelectionItem*)? condition=Condition?)
	 */
	protected void sequence_Selection_ViewElement(EObject context, Selection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         elementID=ID 
	 *         label=STRING 
	 *         association=[Association|QualifiedName] 
	 *         ((link+=Link link+=Link*) | (link+=Link+ columns+=Column columns+=Column*) | (columns+=Column columns+=Column*)?)
	 *     )
	 */
	protected void sequence_Table(EObject context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         elementID=ID 
	 *         label=STRING 
	 *         association=[Association|QualifiedName] 
	 *         ((link+=Link link+=Link*) | (link+=Link+ columns+=Column columns+=Column*) | (columns+=Column columns+=Column*)?) 
	 *         condition=Condition?
	 *     )
	 */
	protected void sequence_Table_ViewElement(EObject context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (long?='long'? elementID=ID label=STRING format=STRING? property=[Property|QualifiedName])
	 */
	protected void sequence_Text(EObject context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         long?='long'? 
	 *         elementID=ID 
	 *         label=STRING 
	 *         format=STRING? 
	 *         property=[Property|QualifiedName] 
	 *         condition=Condition?
	 *     )
	 */
	protected void sequence_Text_ViewElement(EObject context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         layout=Layout 
	 *         startView?='start'? 
	 *         name=ID 
	 *         header=STRING 
	 *         class=[Class|QualifiedName] 
	 *         description=STRING? 
	 *         (elementGroups+=ElementGroup elementGroups+=ElementGroup*)?
	 *     )
	 */
	protected void sequence_UpdateView(EObject context, UpdateView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (welcomeViewGroup?='welcome'? name=ID (views+=View views+=View*)?)
	 */
	protected void sequence_ViewGroup(EObject context, ViewGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (viewGroups+=ViewGroup viewGroups+=ViewGroup*)?
	 */
	protected void sequence_ViewModel(EObject context, ViewModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
